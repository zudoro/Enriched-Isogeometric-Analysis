MODULE GEOMETRY

	USE GLBVAR
	USE PATCH_MAPPING
	USE KNOT_HANDLING

	IMPLICIT NONE
	
! 	IMPLICIT INTEGER (I-N)
! 	IMPLICIT REAL(8) (A-H,O-Z)

CONTAINS

SUBROUTINE GET_GEO()
	
	REAL*8 :: CTL_PTX
	INTEGER :: I, J, II, JJ, K, KK

! 	TEST_KVEC%POLY_ORDER = 2
! 	TEST_KVEC%LENGTH = 11
! 	TEST_NUMBS = 9
! 	TEST_KVEC%KNOTS(0:TEST_KVEC%LENGTH) = (/0.D0, 0.D0, 0.D0, 0.25D0, 0.25D0, 0.5D0, 0.5D0, 0.75D0, 0.75D0, 1.D0, 1.D0, 1.D0/)
! 	TEST_CTL%D = 1
! 	TEST_CTL%PTS(0,0,0) = POINT2D(1.D0, 0.D0)
! 	TEST_CTL%PTS(1,0,0) = POINT2D(1.D0,1.D0)
! 	TEST_CTL%PTS(2,0,0) = POINT2D(0.D0,1.D0)
! 	TEST_CTL%PTS(3,0,0) = POINT2D(-1.D0,1.D0)
! 	TEST_CTL%PTS(4,0,0) = POINT2D(-1.D0,0.D0)
! 	TEST_CTL%PTS(5,0,0) = POINT2D(-1.D0,-1.D0)
! 	TEST_CTL%PTS(6,0,0) = POINT2D(0.D0,-1.D0)
! 	TEST_CTL%PTS(7,0,0) = POINT2D(1.D0,-1.D0)
! 	TEST_CTL%PTS(8,0,0) = POINT2D(1.D0,0.D0)
! 	
! 	DO I = 0, TEST_NUMBS - 1
! 		IF (MOD(I,2)==0) THEN
! 			TEST_CTL%WGTS(I,0,0) = 1.D0
! 		ELSE
! 			TEST_CTL%WGTS(I,0,0) = DCOS(45.D0*DEGREE)
! 		ENDIF
! 	ENDDO

! IGA - Unit circle with crack along positive x-axis
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	GEO_KVEC(1,1)%POLY_ORDER = 2
	GEO_KVEC(1,2)%POLY_ORDER = 2

	GEO_KVEC(1,1)%LENGTH = 5
	GEO_KVEC(1,2)%LENGTH = 7

	GEO_KVEC(1,1)%KNOTS(0:GEO_KVEC(1,1)%LENGTH) = (/0.D0, 0.D0, 0.D0, 1.D0, 1.D0, 1.D0/)
	GEO_KVEC(1,2)%KNOTS(0:GEO_KVEC(1,2)%LENGTH) = (/0.D0, 0.D0, 0.D0, 0.5D0, 0.5D0, 1.D0, 1.D0, 1.D0/)
	
! SET CONTROL POINTS AND WEIGTH
	
	GEO_CTL(1)%D=2
	
	GEO_CTL(1)%PTS(0,0,0) = POINT2D(0.D0,-1.D0)
	GEO_CTL(1)%PTS(1,0,0) = POINT2D(1.D0,-1.D0)
	GEO_CTL(1)%PTS(2,0,0) = POINT2D(1.D0,0.D0)
	
	GEO_CTL(1)%PTS(0,1,0) = POINT2D(-1.D0,-1.D0)
	GEO_CTL(1)%PTS(1,1,0) = POINT2D(0.5D0,-0.5D0)
	GEO_CTL(1)%PTS(2,1,0) = POINT2D(0.5D0,0.D0)
	
	GEO_CTL(1)%PTS(0,2,0) = POINT2D(-1.D0,0.D0)
	GEO_CTL(1)%PTS(1,2,0) = POINT2D(-0.5D0,0.D0)
	GEO_CTL(1)%PTS(2,2,0) = POINT2D(0.D0,0.D0)
	
	GEO_CTL(1)%PTS(0,3,0) = POINT2D(-1.D0,1.D0)
	GEO_CTL(1)%PTS(1,3,0) = POINT2D(0.5D0,0.5D0)
	GEO_CTL(1)%PTS(2,3,0) = POINT2D(0.5D0,0.D0)
	
	GEO_CTL(1)%PTS(0,4,0) = POINT2D(0.D0,1.D0)
	GEO_CTL(1)%PTS(1,4,0) = POINT2D(1.D0,1.D0)
	GEO_CTL(1)%PTS(2,4,0) = POINT2D(1.D0,0.D0)
	
	GEO_CTL(1)%WGTS(0,0,0) = 1.D0
	GEO_CTL(1)%WGTS(1,0,0) = DCOS(45.D0*DEGREE)
	GEO_CTL(1)%WGTS(2,0,0) = 1.D0
	
	GEO_CTL(1)%WGTS(0,1,0) = DCOS(45.D0*DEGREE)
	GEO_CTL(1)%WGTS(1,1,0) = DCOS(45.D0*DEGREE)
	GEO_CTL(1)%WGTS(2,1,0) = 1.D0
	
	GEO_CTL(1)%WGTS(0,2,0) = 1.D0
	GEO_CTL(1)%WGTS(1,2,0) = 1.D0
	GEO_CTL(1)%WGTS(2,2,0) = 1.D0
	
	GEO_CTL(1)%WGTS(0,3,0) = DCOS(45.D0*DEGREE)
	GEO_CTL(1)%WGTS(1,3,0) = DCOS(45.D0*DEGREE)
	GEO_CTL(1)%WGTS(2,3,0) = 1.D0
	
	GEO_CTL(1)%WGTS(0,4,0) = 1.D0
	GEO_CTL(1)%WGTS(1,4,0) = DCOS(45.D0*DEGREE)
	GEO_CTL(1)%WGTS(2,4,0) = 1.D0
	
	IGA_CTL%WGTS(:,:,:) = 1.D0
	
	IGA_KVEC(:) = GEO_KVEC(1,:)

	DO I=1, IGA_ORDER(1) - GEO_KVEC(1,1)%POLY_ORDER
		IGA_KVEC(1) = DEGREE_ELEVATION_KVEC(IGA_KVEC(1))
	ENDDO
	DO I=1, IGA_ORDER(2) - GEO_KVEC(1,2)%POLY_ORDER
		IGA_KVEC(2) = DEGREE_ELEVATION_KVEC(IGA_KVEC(2))
	ENDDO
	
	NUMBS(1,:) = (/IGA_KVEC(1)%LENGTH-IGA_KVEC(1)%POLY_ORDER,IGA_KVEC(2)%LENGTH-IGA_KVEC(2)%POLY_ORDER/)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! EGM - Unit circle with crack along positive x-axis
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	GEO_KVEC(2,1)%POLY_ORDER = 2
	GEO_KVEC(2,2)%POLY_ORDER = 2

	GEO_KVEC(2,1)%LENGTH = 11
	GEO_KVEC(2,2)%LENGTH = 7

	GEO_KVEC(2,1)%KNOTS(0:GEO_KVEC(2,1)%LENGTH) = (/0.D0, 0.D0, 0.D0, 0.25D0, 0.25D0, 0.5D0, 0.5D0, 0.75D0, 0.75D0, 1.D0, 1.D0, 1.D0/)
	GEO_KVEC(2,2)%KNOTS(0:GEO_KVEC(2,2)%LENGTH) = (/0.D0, 0.D0, 0.D0, 0.9D0, 0.9D0, 1.D0, 1.D0, 1.D0/)
	
! SET CONTROL POINTS AND WEIGTH
	GEO_CTL(2)%D=2
	
	GEO_CTL(2)%PTS(0:8,0:1,0) = POINT2D(0.D0,0.D0)

	GEO_CTL(2)%PTS(0,4,0) = POINT2D(1.D0,0.D0)
	GEO_CTL(2)%PTS(1,4,0) = POINT2D(1.D0,-1.D0)
	GEO_CTL(2)%PTS(2,4,0) = POINT2D(0.D0,-1.D0)
	GEO_CTL(2)%PTS(3,4,0) = POINT2D(-1.D0,-1.D0)
	GEO_CTL(2)%PTS(4,4,0) = POINT2D(-1.D0,0.D0)
	GEO_CTL(2)%PTS(5,4,0) = POINT2D(-1.D0,1.D0)
	GEO_CTL(2)%PTS(6,4,0) = POINT2D(0.D0,1.D0)
	GEO_CTL(2)%PTS(7,4,0) = POINT2D(1.D0,1.D0)
	GEO_CTL(2)%PTS(8,4,0) = POINT2D(1.D0,0.D0)
	
	DO I = 0, 8
		GEO_CTL(2)%PTS(I,4,0) = 0.550D0*GEO_CTL(2)%PTS(I,4,0)
		GEO_CTL(2)%PTS(I,2,0) = (0.450D0/0.550D0)*GEO_CTL(2)%PTS(I,4,0)
		GEO_CTL(2)%PTS(I,3,0) = 0.5D0*(GEO_CTL(2)%PTS(I,2,0) + GEO_CTL(2)%PTS(I,4,0))
	ENDDO
	
	DO I=0, 4
		GEO_CTL(2)%WGTS(0:8,I,0) = (/1.D0, DCOS(45.D0*DEGREE), 1.D0, DCOS(45.D0*DEGREE), 1.D0, DCOS(45.D0*DEGREE), 1.D0, DCOS(45.D0*DEGREE), 1.D0/)
	ENDDO
	
	EGM_KVEC(:) = GEO_KVEC(2,:)

	IF (EGM_ORDER(1).GT.GEO_KVEC(2,1)%POLY_ORDER) THEN
		DO I=1, EGM_ORDER(1) - EGM_KVEC(1)%POLY_ORDER
			EGM_KVEC(1) = DEGREE_ELEVATION_KVEC(EGM_KVEC(1))
		ENDDO
	ENDIF
	IF (EGM_ORDER(2).GT.GEO_KVEC(2,2)%POLY_ORDER) THEN
		DO I=1, EGM_ORDER(2) - EGM_KVEC(2)%POLY_ORDER
			EGM_KVEC(2) = DEGREE_ELEVATION_KVEC(EGM_KVEC(2))
		ENDDO
	ENDIF
! 	
! 	IF (EXTRA_KNOTS(1)>0) THEN
! 		GEO_KVEC(1,1) = UNIFORM_KNOT_INSERTION(GEO_KVEC(1,1),EXTRA_KNOTS(1))
! 	ENDIF
! 	IF (EXTRA_KNOTS(2)>0) THEN
! 		GEO_KVEC(1,2) = UNIFORM_KNOT_INSERTION(GEO_KVEC(1,2),EXTRA_KNOTS(2))
! 	ENDIF
	
	NUMBS(2,:) = (/EGM_KVEC(1)%LENGTH-EGM_KVEC(1)%POLY_ORDER,EGM_KVEC(2)%LENGTH-EGM_KVEC(2)%POLY_ORDER/)
	
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	WRITE(*,*)
	WRITE(*,*) '<<< SET GEOMETRIC KNOT, CONTROL POINTS, AND WEIGHT : DONE >>>'
	WRITE(*,*)
		
	BASIS_KVEC(1,:) = IGA_KVEC(:)
	BASIS_KVEC(2,:) = EGM_KVEC(:)
	
	LOCAL_DOF(1) = NUMBS(1,1)*NUMBS(1,2)
	LOCAL_DOF(2) = NUMBS(2,1)*NUMBS(2,2) - NUMBS(2,1)
	DOF = SUM(LOCAL_DOF(:))
	
! GLOBAL INDEX
	ALLOCATE(NDX(2,DOF))
	K = 0
	DO II = 1, NUM_PATCH
		DO I = 1, LOCAL_DOF(II)
			K = K + 1
			NDX(1,K)=MOD(I+(NUMBS(II,1)-1), NUMBS(II,1))
			NDX(2,K)=MOD(INT((I-1)/NUMBS(II,1)) + NUMBS(II,2), NUMBS(II,2))
		ENDDO
	ENDDO
	
	NUMBS(2,2) = NUMBS(2,2) - 1
	
	IF (LOCAL_DOF(2).NE.NUMBS(2,1)*NUMBS(2,2)) THEN
		PRINT*, 'ERROR - GEOMETRY : LOCAL_DOF(2) IN NOT EQUAL TO NUMBS(2,1)*NUMBS(2,2)'
		STOP
	ENDIF
	
	
	WRITE(*,*)
	WRITE(*,*) '<<< SET GLOBAL INDEX : DONE >>>'
	WRITE(*,*)

! CONSTRUCT THE FRAME OF LOCAL INTEGRAL REGIONS
	IR_GRID(:,1,1) = 0.D0
	IR_GRID(:,2,1) = 0.D0
	
! 	PRINT*, GEO_KVEC(1,1)%LENGTH, GEO_KVEC(1,2)%LENGTH

	DO II = 1, NUM_PATCH
		K = 1
		DO I=1, GEO_KVEC(II,1)%LENGTH
			K = K + 1
			IF (DABS(GEO_KVEC(II,1)%KNOTS(I-1) - GEO_KVEC(II,1)%KNOTS(I)).LE.EPS) THEN
				K = K - 1
			ELSE
				IR_GRID(II,1,K) = GEO_KVEC(II,1)%KNOTS(I)
			ENDIF
		ENDDO
		NUMIR(II,1) = K
	ENDDO
	
	DO II = 1, NUM_PATCH
		K = 1
		DO I=1, GEO_KVEC(II,2)%LENGTH
			K = K + 1
			IF (DABS(GEO_KVEC(II,2)%KNOTS(I-1) - GEO_KVEC(II,2)%KNOTS(I)).LE.EPS) THEN
				K = K - 1
			ELSE
				IR_GRID(II,2,K) = GEO_KVEC(II,2)%KNOTS(I)
			ENDIF
		ENDDO
		NUMIR(II,2) = K
	ENDDO

	WRITE(*,*)
	WRITE(*,*) '<<< SET INTEGRAL REGION : DONE >>>'
	WRITE(*,*)

! SET INDEX OF BASIS FUNCTIONS IMPOSED ESSENTIAL BOUNDARY CONDITION
	ALLOCATE(BD_MASK(DOF))
	BD_MASK(:) = .FALSE.
	BD_DOF = 0
	
	K = 0
	DO I=1, LOCAL_DOF(1)
		IF (NDX(1,I)==0 .OR. NDX(1,I)==NUMBS(1,1)-1 .OR. NDX(2,I)==0 .OR. NDX(2,I)==NUMBS(1,2)-1) THEN
			K = K + 1
			BDNDX(1,K)%LC_NDX(:) = NDX(:,I)
			BDNDX(1,K)%GL_NDX = I
! 			BD_MASK(I)=.TRUE.
			BD_DOF = BD_DOF + 1
		ENDIF
	ENDDO
	BDNDX(1,:)%LC_NUM = K
		
	K = 0
	DO I = LOCAL_DOF(1) + 1, DOF
		IF (NDX(1,I)==0 .OR. NDX(1,I)==NUMBS(2,1)-1) THEN
			K = K + 1
			BDNDX(2,K)%LC_NDX(:) = NDX(:,I)
			BDNDX(2,K)%GL_NDX = I
! 			BD_MASK(I)=.TRUE.
			BD_DOF = BD_DOF + 1
		ENDIF
	ENDDO
	BDNDX(2,:)%LC_NUM = K
	
	WRITE(*,*)
	WRITE(*,*) '<<< SET LOCAL INDEX CORRESPONDING BASIS FUNCTIONS ON BOUNDARY IMPOSED ESSENTIAL BOUNDARY CONDITION : DONE >>>'
	WRITE(*,*)

	!!  GENERATE BINOMIAL COEFFICIENTS

	DO I = 1, MAX_DIFF_ORDER
		DO J = 0, MAX_DIFF_ORDER
			BINOM(I,J) = 1.0D0
		ENDDO
	ENDDO

	BINOM(1,0) = 1.0D0
	BINOM(1,1) = 1.0D0
	DO I = 2, MAX_DIFF_ORDER
		BINOM(I,0) = BINOM(I-1,0)
		DO J = 1, I-1
			BINOM(I,J) = BINOM(I-1,J-1) + BINOM(I-1,J)
		ENDDO
		BINOM(I,I) = BINOM(I-1,I-1)
	ENDDO

END SUBROUTINE GET_GEO

END MODULE GEOMETRY

