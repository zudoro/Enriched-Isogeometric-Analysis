MODULE BOUNDARY

	USE INTEGRATION
	USE LUDECOMPOSITION

  implicit integer (i-n)
	implicit real(8) (a-h,o-z)

CONTAINS

SUBROUTINE IMPOSEBD(K, F)

	REAL*8, INTENT(INOUT) :: K(2*DOF,2*DOF), F(2*DOF)
	REAL*8 :: SUB_K(SUM(DR_BDNDX(:,1)%LC_NUM),SUM(DR_BDNDX(:,1)%LC_NUM))
	
	TYPE(POINT2D) :: PINCH_DISP(2), SUB_F(SUM(DR_BDNDX(:,1)%LC_NUM))
	REAL*8 :: DMY_SUB_K(SUM(DR_BDNDX(:,1)%LC_NUM), SUM(DR_BDNDX(:,1)%LC_NUM)), DD
	INTEGER :: I, J, II, JJ, KK, INDX(SUM(DR_BDNDX(:,1)%LC_NUM)), PINCH_BS_INDX(2), LC_NUM_SUM
	TYPE(POINT2D) :: LN_INT
	
	IF (BCTYPE=='neuma') THEN
! IMPOSE NEUMANN BOUNDARY CONDITION
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	CALL IMPOSE_NEUMANN_BD(F)

! 	CALL TS_NEUMANN(F)

! PINCH TWO POINTS IN THE CASE OF IMPOSING NEUMANN B.C. ON ALL BOUNDARY
! 	PINCH_BS_INDX(1) = 1
! 	PINCH_BS_INDX(2) = SUM(LOCAL_DOF(1:3))
! 
! 	!! Physical point = (-2, -2)
! 	PINCH_DISP(1) = EX_DISP(POINT2D(0.D0,0.D0),1) !<----- CAUTION!!!!! PUT A REFERENCE POINT CORRESPONDING TO A PINCH POINT ON PHYSICAL DOMAIN
! 	!! Physical point = (0, 0)
! 	PINCH_DISP(2) = EX_DISP(POINT2D(1.D0,1.D0),3) !<----- CAUTION!!!!! PUT A REFERENCE POINT CORRESPONDING TO A PINCH POINT ON PHYSICAL DOMAIN
! 
! 	DO J=1, 2*DOF
! 		F(J) = F(J) - PINCH_DISP(1)%X*K(J,PINCH_BS_INDX(1)) - PINCH_DISP(1)%Y*K(J, DOF + PINCH_BS_INDX(1))
! 		F(J) = F(J) - PINCH_DISP(2)%X*K(J, PINCH_BS_INDX(2)) - PINCH_DISP(2)%Y*K(J, DOF + PINCH_BS_INDX(2))
! 	ENDDO
! 
! 	F(PINCH_BS_INDX(1)) = PINCH_DISP(1)%X; F(PINCH_BS_INDX(2)) = PINCH_DISP(2)%X
! 	F(DOF + PINCH_BS_INDX(1)) = PINCH_DISP(1)%Y; F(DOF + PINCH_BS_INDX(2)) = PINCH_DISP(2)%Y
! 	DO J=1, 2*DOF
! 		K(PINCH_BS_INDX(1),J) = 0.0D0; K(PINCH_BS_INDX(2),J) = 0.D0
! 		K(DOF + PINCH_BS_INDX(1),J) = 0.0D0; K(DOF + PINCH_BS_INDX(2), J) = 0.D0
! 
! 		K(J,PINCH_BS_INDX(1)) = 0.0D0; K(J,PINCH_BS_INDX(2)) = 0.D0
! 		K(J,DOF + PINCH_BS_INDX(1)) = 0.0D0; K(J,DOF + PINCH_BS_INDX(2)) = 0.D0
! 	ENDDO
! 	K(PINCH_BS_INDX(1), PINCH_BS_INDX(1)) = 1.0D0; K(PINCH_BS_INDX(2),PINCH_BS_INDX(2)) = 1.D0
! 	K(DOF + PINCH_BS_INDX(1), DOF + PINCH_BS_INDX(1)) = 1.0D0; K(DOF + PINCH_BS_INDX(2),DOF + PINCH_BS_INDX(2)) = 1.D0

	PRINT*, 
	PRINT*, '<<< IMPOSING NEUMANN BOUNDARY CONDITIONS : DONE >>>'
	PRINT*, 

	ELSE
! IMPOSE DIRICHLET BOUNDARY CONDITION BY USING LEAST SQUARE METHOD
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	SUB_K(:,:) = 0.D0
	SUB_F(:) = POINT2D(0.D0,0.D0)

! 	OPEN(121, FILE = 'least_square')
	
	CALL GEN_BD_LN(SUB_K, SUB_F)
	
! 	PRINT*, 'HERE 1'
! 	OPEN(124, FILE = './data/sub_k')
! 	OPEN(125, FILE = './data/sub_f')
! 	DO I=1, SUM(DR_BDNDX(:,1)%LC_NUM)
! 		WRITE(124, 102) (SUB_K(I,J), J=1, SUM(DR_BDNDX(:,1)%LC_NUM))
! 		WRITE(125, 102) SUB_F(I)
! 	ENDDO
! 	CLOSE(124)
! 	CLOSE(125)
	
	102 FORMAT(1000(f20.8,1x))
	
	DMY_SUB_K(:,:) = SUB_K(:,:)
	CALL LUDCMP(DMY_SUB_K, SUM(DR_BDNDX(:,1)%LC_NUM), SUM(DR_BDNDX(:,1)%LC_NUM), INDX, DD)
	CALL LUBKSB(DMY_SUB_K, SUM(DR_BDNDX(:,1)%LC_NUM), SUM(DR_BDNDX(:,1)%LC_NUM), INDX, SUB_F(:)%X)
	
! 	OPEN(1, FILE = './data/sub_solx')
! 	DO I = 1, SUM(DR_BDNDX(:,1)%LC_NUM)
! 		WRITE(1,*) SUB_F(I)%X
! 	ENDDO
! 	CLOSE(1)

	DMY_SUB_K(:,:) = SUB_K(:,:)
	CALL LUDCMP(DMY_SUB_K, SUM(DR_BDNDX(:,1)%LC_NUM), SUM(DR_BDNDX(:,1)%LC_NUM), INDX, DD)
	CALL LUBKSB(DMY_SUB_K, SUM(DR_BDNDX(:,1)%LC_NUM), SUM(DR_BDNDX(:,1)%LC_NUM), INDX, SUB_F(:)%Y)
	
! 	OPEN(1, FILE = './data/sub_soly')
! 	DO I = 1, SUM(DR_BDNDX(:,1)%LC_NUM)
! 		WRITE(1,*) SUB_F(I)%Y
! 	ENDDO
! 	CLOSE(1)

! 	SUBTRACT EXACT SOLUTIONS FROM THE LOAD VECTOR
	DO II=1, NUM_PATCH
		IF (II.EQ.1) THEN
			LC_NUM_SUM = 0
		ELSE
			LC_NUM_SUM = SUM(DR_BDNDX(1:II-1,1)%LC_NUM)
		ENDIF
		DO I=1, DR_BDNDX(II,1)%LC_NUM
			DO J=1, 2*DOF
				F(J) = F(J) - SUB_F(LC_NUM_SUM + I)%X*K(J, DR_BDNDX(II,I)%GL_NDX) - SUB_F(LC_NUM_SUM + I)%Y*K(J, DOF + DR_BDNDX(II,I)%GL_NDX)
			ENDDO
		ENDDO
	ENDDO

	DO II=1, NUM_PATCH
		IF (II.EQ.1) THEN
			LC_NUM_SUM = 0
		ELSE
			LC_NUM_SUM = SUM(DR_BDNDX(1:II-1,1)%LC_NUM)
		ENDIF
		DO I=1, DR_BDNDX(II,1)%LC_NUM
			F(DR_BDNDX(II,I)%GL_NDX) = SUB_F(LC_NUM_SUM + I)%X
			F(DOF + DR_BDNDX(II,I)%GL_NDX) = SUB_F(LC_NUM_SUM + I)%Y
			DO J=1, 2*DOF
				K(DR_BDNDX(II,I)%GL_NDX,J) = 0.0D0
				K(J,DR_BDNDX(II,I)%GL_NDX) = 0.0D0
				K(DOF + DR_BDNDX(II,I)%GL_NDX,J) = 0.0D0
				K(J, DOF + DR_BDNDX(II,I)%GL_NDX) = 0.0D0
			ENDDO
			K(DR_BDNDX(II,I)%GL_NDX, DR_BDNDX(II,I)%GL_NDX) = 1.0D0
			K(DOF + DR_BDNDX(II,I)%GL_NDX, DOF + DR_BDNDX(II,I)%GL_NDX) = 1.0D0
		ENDDO
	ENDDO
	
	!!--------------------------------------------------------------------------------------------------------------------!!
	!! Impose zero Dirichlet boundary conditions
	DO II=1, NUM_PATCH
		IF (II.EQ.1) THEN
			LC_NUM_SUM = 0
		ELSE
			LC_NUM_SUM = SUM(ZERO_BDNDX(1:II-1,1)%LC_NUM)
		ENDIF
		DO I=1, ZERO_BDNDX(II,1)%LC_NUM
			F(ZERO_BDNDX(II,I)%GL_NDX) = 0.D0
			F(DOF + ZERO_BDNDX(II,I)%GL_NDX) = 0.D0
			DO J=1, 2*DOF
				K(ZERO_BDNDX(II,I)%GL_NDX, J) = 0.0D0
				K(J, ZERO_BDNDX(II,I)%GL_NDX) = 0.0D0
				K(DOF + ZERO_BDNDX(II,I)%GL_NDX, J) = 0.0D0
				K(J, DOF + ZERO_BDNDX(II,I)%GL_NDX) = 0.0D0
			ENDDO
			K(ZERO_BDNDX(II,I)%GL_NDX, ZERO_BDNDX(II,I)%GL_NDX) = 1.0D0
			K(DOF + ZERO_BDNDX(II,I)%GL_NDX, DOF + ZERO_BDNDX(II,I)%GL_NDX) = 1.0D0
		ENDDO
	ENDDO
	
	PRINT*, 
	PRINT*, '<<< IMPOSING ESSENTIAL BOUNDARY CONDITIONS BY USING LEAST SQUARE METHOD : DONE >>>'
	PRINT*, 
	
	ENDIF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


END SUBROUTINE IMPOSEBD

END MODULE BOUNDARY
!------------------------------------!