MODULE PATCH_MAPPING

	USE NURBS

	implicit integer (i-n)
	implicit real(8) (a-h,o-z)

CONTAINS

	!!  GET THE CORRESPONDING POINT ON THE PHYSICAL SPACE OF GIVE POINT ON THE PARAMETRIC SPACE
	TYPE(POINT2D) FUNCTION GET_PHY_PT(REF_PT, PATCH)

		TYPE(POINT2D), INTENT(IN) :: REF_PT
		INTEGER, INTENT(IN) :: PATCH

		GET_PHY_PT = GET_POINT_NURVE_SURFACE_2D(REF_PT,GEO_KVEC(PATCH,:),GEO_CTL(PATCH))

	END FUNCTION GET_PHY_PT


	!!  GET THE CORRESPONDING POINT ON THE PARAMETRIC SPACE OF GIVE POINT ON THE PHYSICAL SPACE
	TYPE(POINT2D) FUNCTION GET_REF_PT(PHY_PT, PATCH, SIDE)

		TYPE(POINT2D), INTENT(IN) :: PHY_PT
		INTEGER, INTENT(IN) :: PATCH
		CHARACTER(LEN=1), OPTIONAL, INTENT(IN) :: SIDE

		TYPE(FUNCTION_2D) :: DIFF_NURBS(2)
		TYPE(POINT2D) :: NEW_PT, OLD_PT, TMP_PT
		REAL(8) :: ERROR, INV_J, R, THETA
		INTEGER :: ITER, K(3), INDX_SUPP

		ERROR = 1.0D0
		
! 		IF (DABS(PHY_PT%X)<=EPS) THEN
! 			PHY_PT%X = 0.D0
! 		ENDIF
! 		IF (DABS(PHY_PT%Y)<=EPS) THEN
! 			PHY_PT%Y = 0.D0
! 		ENDIF
		
! 		IF (PATCH.LE.NUM_IGA_PATCH) THEN
! 			IF (DABS(PHY_PT%X).LE.EPS .AND. DABS(PHY_PT%Y).LE.EPS) THEN
! 				IF (PATCH==1) THEN
! 					OLD_PT = POINT2D(0.D0,0.D0)
! 				ELSEIF (PATCH==2) THEN
! 					OLD_PT = POINT2D(1.D0,0.D0)
! 				ELSEIF (PATCH==3) THEN
! 					OLD_PT = POINT2D(1.D0,1.D0)
! 				ENDIF
! 			ELSEIF (DABS(PHY_PT%X).LE.EPS .AND. PHY_PT%Y.GT.EPS) THEN
! 				IF (PATCH==1) THEN
! 					OLD_PT = POINT2D(0.D0, 0.5D0)
! 				ELSEIF (PATCH==2) THEN
! 					OLD_PT = POINT2D(1.D0, 0.5D0)
! 				ELSEIF (PATCH==3) THEN
! 					PRINT*, 'ERROR 1 - GET_REF_PT : SET INITIAL OLD_PT WRONG!!'
! 					STOP
! 				ELSE
! 					PRINT*, 'ERROR 1 - GET_REF_PT : SET INITIAL OLD_PT WRONG!!'
! 					STOP
! 				ENDIF
! 			ELSEIF (PHY_PT%X.LT.EPS .AND. DABS(PHY_PT%Y).LE.EPS) THEN
! 				IF (PATCH==2) THEN
! 					OLD_PT = POINT2D(0.5D0, 0.D0)
! 				ELSEIF (PATCH==3) THEN
! 					OLD_PT = POINT2D(0.5D0, 1.D0)
! 				ELSE
! 					PRINT*, 'ERROR 2 - GET_REF_PT : SET INITIAL OLD_PT WRONG!!'
! 					STOP
! 				ENDIF
! 			ELSE
! 				OLD_PT%X = 0.5D0
! 				OLD_PT%Y = 0.5D0
! 			ENDIF
! 		ELSE
! 			CALL GET_RTHETA(R, THETA, PHY_PT)
! 			IF (R.LE.0.45D0) THEN
! 				OLD_PT%Y = 0.45D0
! 			ELSE
! 				OLD_PT%Y = 0.95D0
! 			ENDIF
! 			IF (THETA.GE.EPS .AND. THETA.LT.0.5D0*PI) THEN
! 				OLD_PT%X = 0.125D0
! 				INDX_SUPP = 1
! 			ELSEIF (THETA.GE.0.5D0*PI .AND. THETA.LT.PI) THEN
! 				OLD_PT%X = 0.375D0
! 				INDX_SUPP = 2
! 			ELSEIF (THETA.GE.PI .AND. THETA.LT.1.5D0*PI) THEN
! 				OLD_PT%X = 0.625D0
! 				INDX_SUPP = 3
! 			ELSEIF (THETA.GE.1.5D0*PI .AND. THETA.LT.2.D0*PI) THEN
! 				OLD_PT%X = 0.875D0
! 				INDX_SUPP = 4
! 			ENDIF
! 		ENDIF
! 
! 		137 CONTINUE
! ! 		PRINT*, OLD_PT 

		OLD_PT%X = 0.5D0
		OLD_PT%Y = 0.5D0

		ITER = 0
		K(:) = 0
		DO WHILE (ERROR>TOLERANCE)
			ITER = ITER + 1
			CALL GET_DIFF_NURVE_SURFACE_2D(DIFF_NURBS,OLD_PT,GEO_KVEC(PATCH,:),GEO_CTL(PATCH),1)

			TMP_PT%X = DIFF_NURBS(1)%VAL(0,0)-PHY_PT%X
			TMP_PT%Y = DIFF_NURBS(2)%VAL(0,0)-PHY_PT%Y

			ERROR = MAX(DABS(TMP_PT%X),DABS(TMP_PT%Y))
			
			IF (ERROR<TOLERANCE .AND. OLD_PT%X.GE.0.D0 .AND. OLD_PT%X.LE.1.D0 .AND. OLD_PT%Y.GE.0.D0 .AND. OLD_PT%Y.LE.1.D0) THEN
				GET_REF_PT = OLD_PT
				GOTO 999
			ELSE
				INV_J = 1.0D0 / (DIFF_NURBS(1)%VAL(1,0)*DIFF_NURBS(2)%VAL(0,1)-DIFF_NURBS(1)%VAL(0,1)*DIFF_NURBS(2)%VAL(1,0))
				NEW_PT%X = OLD_PT%X - INV_J*(DIFF_NURBS(2)%VAL(0,1)*TMP_PT%X-DIFF_NURBS(1)%VAL(0,1)*TMP_PT%Y)
				NEW_PT%Y = OLD_PT%Y - INV_J*(DIFF_NURBS(1)%VAL(1,0)*TMP_PT%Y-DIFF_NURBS(2)%VAL(1,0)*TMP_PT%X)
				OLD_PT = NEW_PT
				
! 				PRINT*, 'phy_pt', PHY_PT
! 				print*, 'old_pt', old_pt
! 				read(*,*)
! 				PRINT*, 'GET_REF_PT-HERE2'
				
				IF (OLD_PT%X.LT.0.D0 .OR. OLD_PT%X.GT.1.D0 .OR. OLD_PT%Y.LT.0.D0 .OR. OLD_PT%Y.GT.1.D0) THEN
					IF (DABS(OLD_PT%X)<=5.0D-8 .OR. DABS(OLD_PT%Y)<=5.0D-8) THEN
						IF (K(3).NE.1) THEN
							OLD_PT%X = DABS(OLD_PT%X)
							OLD_PT%Y = DABS(OLD_PT%Y)
							K(3) = 1
							GOTO 11
						ENDIF
					ENDIF
					
					IF (DABS(PHY_PT%X)<=5.0D-8 .AND. DABS(PHY_PT%Y)>0.D0) THEN
						K(1) = K(1) + 1
						IF (PHY_PT%Y>0.D0) THEN
! 							PRINT*, 'HERE-1', PATCH
							OLD_PT%X = 1.D0 - 0.0001D0*K(1)
							OLD_PT%Y = 1.D0 - 0.0001D0*K(1)
							GOTO 11
						ELSE
! 							PRINT*, 'HERE-2', PATCH
							OLD_PT%X = 0.D0 + 0.0001D0*K(1)
							OLD_PT%Y = 0.D0 + 0.0001D0*K(1)
							GOTO 11
						ENDIF
					ELSEIF (DABS(PHY_PT%Y)<=5.0D-8 .AND. PHY_PT%X>0.D0) THEN
						K(1) = K(1) + 1
! 						PRINT*, 'HERE-3', PATCH
						OLD_PT%X = 1.D0 - 0.0001D0*K(1)
						OLD_PT%Y = 0.D0 + 0.0001D0*K(1)
						GOTO 11
					ENDIF
				
					K(1) = K(1) + 1
					OLD_PT%X = 0.01D0*K(1)
					ITER = 0
					
					K(2) = K(2) + 1
					OLD_PT%Y = 0.01D0*K(2)
				ENDIF
			ENDIF
			11 CONTINUE
		ENDDO
		
		IF (ITER==MAX_ITERATION) THEN
			PRINT *, '[ERROR]  CANNOT FIND REFERENCE POINT !'
		ENDIF

		999 CONTINUE
		
! 		PRINT*, 'GET_REF_PT-HERE3'
		
	END FUNCTION GET_REF_PT


	!! BROYDEN METHOD (QUASI - NEWTON METHOD) FOR FINDING POINT EVALUATION OF INVERSE EXOTIC GEO. MAP. 
! 	TYPE(POINT2D) FUNCTION BROYDEN(REF_PT, PATCH)
! 	
! 		TYPE(POINT2D), INTENT(IN) :: REF_PT
! 		INTEGER, INTENT(IN) :: PATCH
! 		
! 		TYPE(POINT2D) :: OLD_PT, NEW_PT, V
! 		TYPE(MATRIX_22) :: JACOB
! 		
! 		JACOB = GET_JACOBIAN_MATRIX(REF_PT, PATCH)
! 		
! ! 		IF(PATCH==1) THEN
! ! 			CALL GET_DIFF_NURVE_SURFACE_2D(DIFF_NURBS,OLD_PT,GEO_KVEC(1,:),GEO_CTL(1),1)
! ! 		ELSE
! ! 			CALL GET_DIFF_EXOTIC_GEO_MAP(DIFF_NURBS,OLD_PT,GEO_KVEC(PATCH,:),GEO_CTL(PATCH),1)
! ! 		ENDIF
! 		
! 		V = GET_POINT_NURVE_SURFACE_2D(REF_PT,KVEC(PATCH,:),CTL(PATCH))
! 		
! 	END FUNCTION BROYDEN
	
	
	!! HOMOTOPY OR CONTINUATION ALGORITHM TO FIND GOOD INITIAL APPROXIMATION FOR NEWTON'S OR BROYDEN'S METHOD
	!! REFERENCE :: NUMERICAL ANALYSIS (BURDEN & FAIR)
	TYPE(POINT2D) FUNCTION GOOD_INITIAL(PHY_PT, PATCH)
		
		TYPE(POINT2D), INTENT(IN) :: PHY_PT
		INTEGER, INTENT(IN) :: PATCH
		
		TYPE(FUNCTION_2D) :: DIFF_NURBS(2)
		TYPE(MATRIX_22) :: JACOB, INV_JACOB
		TYPE(POINT2D) :: K(4), OLD_PT, INI_B
		INTEGER :: I, J, II, JJ, MAX_IT
		REAL*8 :: STEP_H
		
		MAX_IT = 10
		STEP_H = 1.D0/(1.D0*MAX_IT)
		OLD_PT = POINT2D(0.5D0,0.5D0)
		
! 		CALL GET_DIFF_NURVE_SURFACE_2D(DIFF_NURBS,OLD_PT,GEO_KVEC(PATCH,:),GEO_CTL(PATCH),1)

		INI_B = GET_POINT_NURVE_SURFACE_2D(OLD_PT,GEO_KVEC(PATCH,:),GEO_CTL(PATCH))
		INI_B%X = -STEP_H*(INI_B%X - PHY_PT%X)
		INI_B%Y = -STEP_H*(INI_B%Y - PHY_PT%Y)
		
		DO I = 1, MAX_IT
			JACOB = GET_JACOBIAN_MATRIX(OLD_PT, PATCH)
			INV_JACOB = .INVERSE.JACOB
			K(1)%X = DOT_PRODUCT((/INV_JACOB%ENT(1,1), INV_JACOB%ENT(1,2)/), (/INI_B%X, INI_B%Y/))
			K(1)%Y = DOT_PRODUCT((/INV_JACOB%ENT(2,1), INV_JACOB%ENT(2,2)/), (/INI_B%X, INI_B%Y/))
			
			JACOB = GET_JACOBIAN_MATRIX(POINT2D(OLD_PT%X + 0.5D0*K(1)%X, OLD_PT%Y + 0.5D0*K(1)%Y), PATCH)
			INV_JACOB = .INVERSE.JACOB
			K(2)%X = DOT_PRODUCT((/INV_JACOB%ENT(1,1), INV_JACOB%ENT(1,2)/), (/INI_B%X, INI_B%Y/))
			K(2)%Y = DOT_PRODUCT((/INV_JACOB%ENT(2,1), INV_JACOB%ENT(2,2)/), (/INI_B%X, INI_B%Y/))
			
			JACOB = GET_JACOBIAN_MATRIX(POINT2D(OLD_PT%X + 0.5D0*K(2)%X, OLD_PT%Y + 0.5D0*K(2)%Y), PATCH)
			INV_JACOB = .INVERSE.JACOB
			K(3)%X = DOT_PRODUCT((/INV_JACOB%ENT(1,1), INV_JACOB%ENT(1,2)/), (/INI_B%X, INI_B%Y/))
			K(3)%Y = DOT_PRODUCT((/INV_JACOB%ENT(2,1), INV_JACOB%ENT(2,2)/), (/INI_B%X, INI_B%Y/))
			
			JACOB = GET_JACOBIAN_MATRIX(POINT2D(OLD_PT%X + 0.5D0*K(3)%X, OLD_PT%Y + 0.5D0*K(3)%Y), PATCH)
			INV_JACOB = .INVERSE.JACOB
			K(4)%X = DOT_PRODUCT((/INV_JACOB%ENT(1,1), INV_JACOB%ENT(1,2)/), (/INI_B%X, INI_B%Y/))
			K(4)%Y = DOT_PRODUCT((/INV_JACOB%ENT(2,1), INV_JACOB%ENT(2,2)/), (/INI_B%X, INI_B%Y/))
			
			OLD_PT%X = OLD_PT%X + (1.D0/6.D0)*(K(1)%X + 2.D0*K(2)%X + 2.D0*K(3)%X + K(4)%X)
			OLD_PT%Y = OLD_PT%Y + (1.D0/6.D0)*(K(1)%Y + 2.D0*K(2)%Y + 2.D0*K(3)%Y + K(4)%Y)
		ENDDO
		
		GOOD_INITIAL = OLD_PT
	END FUNCTION GOOD_INITIAL
	
	!!  GET JACOBIAN OF THE GEOMETRIC MAPPING
	TYPE(MATRIX_22) FUNCTION GET_JACOBIAN_MATRIX(REF_PT, PATCH)

		TYPE(POINT2D), INTENT(IN) :: REF_PT
		INTEGER, INTENT(IN) :: PATCH

		TYPE(FUNCTION_2D) :: DIFF_NURBS(2)
	
		CALL GET_DIFF_NURVE_SURFACE_2D(DIFF_NURBS,REF_PT,GEO_KVEC(PATCH,:),GEO_CTL(PATCH),1)

! 		IF (PRESENT(PATCH)) THEN
! 			CALL GET_DIFF_NURVE_SURFACE_2D(DIFF_NURBS,REF_PT,GEO_KVEC(PATCH,:),GEO_CTL(PATCH),1)
! 		ELSE
! 			CALL GET_DIFF_NURVE_SURFACE_2D(DIFF_NURBS,REF_PT,GEO_KVEC(1,:),GEO_CTL(1),1)
! 		ENDIF

		GET_JACOBIAN_MATRIX%ENT(1,1) = DIFF_NURBS(1)%VAL(1,0)
		GET_JACOBIAN_MATRIX%ENT(1,2) = DIFF_NURBS(1)%VAL(0,1)
		GET_JACOBIAN_MATRIX%ENT(2,1) = DIFF_NURBS(2)%VAL(1,0)
		GET_JACOBIAN_MATRIX%ENT(2,2) = DIFF_NURBS(2)%VAL(0,1)

	END FUNCTION GET_JACOBIAN_MATRIX

	REAL*8 FUNCTION GET_DET_LN(REF_PT, GAMMA, PATCH)
	
		TYPE(POINT2D), INTENT(IN) :: REF_PT
		INTEGER, INTENT(IN) :: GAMMA
		INTEGER, INTENT(IN) :: PATCH
	
		TYPE(FUNCTION_2D) :: DIFF_NURBS(2)
	
		CALL GET_DIFF_NURVE_SURFACE_2D(DIFF_NURBS,REF_PT,GEO_KVEC(PATCH,:),GEO_CTL(PATCH),1)
	
		IF (PATCH.LE.NUM_IGA_PATCH) THEN
			IF (GAMMA.EQ.2 .OR. GAMMA.EQ.4 .OR. GAMMA.EQ.6) THEN
	! 			PRINT*, DIFF_NURBS(1:2)%VAL(0,1)
				GET_DET_LN = DSQRT(DIFF_NURBS(1)%VAL(0,1)**2 + DIFF_NURBS(2)%VAL(0,1)**2)
			ELSEIF (GAMMA==1 .OR. GAMMA==3 .OR. GAMMA==5) THEN
				GET_DET_LN = DSQRT(DIFF_NURBS(1)%VAL(1,0)**2 + DIFF_NURBS(2)%VAL(1,0)**2)
			ELSE
				PRINT*, 'ERROR - GET_DET_LN : 1'
				STOP
			ENDIF
		ELSE
			IF (GAMMA.EQ.1 .OR. GAMMA.EQ.6) THEN
	! 			PRINT*, DIFF_NURBS(1:2)%VAL(0,1)
				GET_DET_LN = DSQRT(DIFF_NURBS(1)%VAL(0,1)**2 + DIFF_NURBS(2)%VAL(0,1)**2)
			ELSE
				PRINT*, 'ERROR - GET_DET_LN : 2'
				STOP
			ENDIF
		ENDIF

	END FUNCTION GET_DET_LN
	
	REAL*8 FUNCTION GET_DET_DR(REF_PT, PATCH, GAMMA_HAT)
	
		TYPE(POINT2D), INTENT(IN) :: REF_PT
		CHARACTER(LEN=1), INTENT(IN) :: GAMMA_HAT
		INTEGER, INTENT(IN) :: PATCH
	
		TYPE(FUNCTION_2D) :: DIFF_NURBS(2)
	
		
		CALL GET_DIFF_NURVE_SURFACE_2D(DIFF_NURBS,REF_PT,GEO_KVEC(PATCH,:),GEO_CTL(PATCH),1)
		
	
		IF (GAMMA_HAT=='B' .OR. GAMMA_HAT=='T') THEN
			GET_DET_DR = DSQRT(DIFF_NURBS(1)%VAL(1,0)**2 + DIFF_NURBS(2)%VAL(1,0)**2)
		ELSEIF (GAMMA_HAT=='L' .OR. GAMMA_HAT=='R') THEN
			GET_DET_DR = DSQRT(DIFF_NURBS(1)%VAL(0,1)**2 + DIFF_NURBS(2)%VAL(0,1)**2)
		ELSE
			PRINT*, 'ERROR - GET_DET_DR : 1'
				STOP
		ENDIF

	END FUNCTION GET_DET_DR
	
	REAL*8 FUNCTION GET_DET_SN(REF_PT, PATCH, SN_FACTOR, GAMMA_HAT)
	
		TYPE(POINT2D), INTENT(IN) :: REF_PT
		CHARACTER(LEN=1), INTENT(IN) :: GAMMA_HAT
		INTEGER, INTENT(IN) :: PATCH, SN_FACTOR
	
		TYPE(FUNCTION_2D) :: DIFF_NURBS(2)
	
	
		CALL GET_DIFF_NURVE_SURFACE_2D(DIFF_NURBS,REF_PT,GEO_KVEC(PATCH,:),GEO_CTL(PATCH),1)
	
	
		IF (GAMMA_HAT=='B' .OR. GAMMA_HAT=='T') THEN
			GET_DET_SN = DSQRT((DIFF_NURBS(1)%VAL(1,0)*SN_FACTOR*(REF_PT%Y)**(SN_FACTOR-1))**2 + (DIFF_NURBS(2)%VAL(1,0)*SN_FACTOR*(REF_PT%Y)**(SN_FACTOR-1))**2)
		ELSEIF (GAMMA_HAT=='L' .OR. GAMMA_HAT=='R') THEN
			GET_DET_SN = DSQRT((DIFF_NURBS(1)%VAL(0,1)*SN_FACTOR*(REF_PT%Y)**(SN_FACTOR-1))**2 + (DIFF_NURBS(2)%VAL(0,1)*SN_FACTOR*(REF_PT%Y)**(SN_FACTOR-1))**2)
		ELSE
			PRINT*, 'ERROR - GET_DET_SN : 1'
				STOP
		ENDIF

	END FUNCTION GET_DET_SN

	!!  GET SECOND-ORDER PARTIAL DERIVATIVES
	TYPE(SECOND_PARTIAL_DERIVATIVES) FUNCTION GET_PARTIAL(REF_PT, PATCH)

		TYPE(POINT2D), INTENT(IN) :: REF_PT
		INTEGER, OPTIONAL, INTENT(IN) :: PATCH

		TYPE(FUNCTION_2D) :: DIFF_NURBS(2)

		IF (PRESENT(PATCH)) THEN
			CALL GET_DIFF_NURVE_SURFACE_2D(DIFF_NURBS,REF_PT,GEO_KVEC(PATCH,:),GEO_CTL(PATCH),2)
		ELSE
			CALL GET_DIFF_NURVE_SURFACE_2D(DIFF_NURBS,REF_PT,GEO_KVEC(1,:),GEO_CTL(1),2)
		ENDIF

		GET_PARTIAL%X(1) = DIFF_NURBS(1)%VAL(2,0)
		GET_PARTIAL%X(2) = DIFF_NURBS(1)%VAL(1,1)
		GET_PARTIAL%X(3) = DIFF_NURBS(1)%VAL(0,2)

		GET_PARTIAL%Y(1) = DIFF_NURBS(2)%VAL(2,0)
		GET_PARTIAL%Y(2) = DIFF_NURBS(2)%VAL(1,1)
		GET_PARTIAL%Y(3) = DIFF_NURBS(2)%VAL(0,2)

	END FUNCTION GET_PARTIAL

TYPE(POINT2D) FUNCTION AF_TRANS(REF_PT)
	
	TYPE(POINT2D), INTENT(IN) :: REF_PT
	
	AF_TRANS = POINT2D(REF_PT%X + 1.D0, REF_PT%Y + (1.D0+DSQRT(2.D0)))
	
END FUNCTION AF_TRANS

END MODULE PATCH_MAPPING

